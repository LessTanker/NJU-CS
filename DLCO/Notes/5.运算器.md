## 1.加法器

### （1）全加器（FA）

- 输入为加数、被加数和低位进位Cin，输出为和F、进位Cout 
- 计算公式：$$F=A\oplus B\oplus Cin\quad Cout=A\cdot B+A\cdot Cin+B\cdot Cin$$
### （2）并行进位加法器（CLA）

- 采用先行进位方式
- 定义辅助函数：$$P_i=A_i+B_i\quad Q_i=A_i\cdot B_i$$
- 全加逻辑方程：$$F_i=A_i\oplus B_i\oplus C_{i-1}\quad C_i=G_i+P_i\cdot C_{i-1}\quad (i=1,2,\cdots n)$$
<img src=./shots/CLA与CLU.png width=600 height=500/>

### （3）带标志加法器

- 溢出标志$OF=C_n\oplus C_{n-1}$
- 符号标志$SF=F_{n-1}$
- 零标志$ZF=1$当且仅当$F=0$
- 进位/借位标志$CF=Cout\oplus Cin$

## 2.补码加减运算

- $[x+y]_{\text{补}}=[x]_{\text{补}}+[y]_{\text{补}}\quad \pmod{2^n}$
- $[x-y]_{\text{补}}=[x]_{\text{补}}+[-y]_{\text{补}}\quad \pmod{2^n}$

- 溢出判断逻辑表达式：
	- $Overflow=C_{n-1}\oplus C_n$
	- $Overflow=X_{n-1}\cdot Y_{n-1}\cdot \overline{F_{n-1}}+\overline{X_{n-1}}\cdot \overline{Y_{n-1}}\cdot F_{n-1}$

#### （1）无符号数比较规则

|比较方式|判断条件|
|---|---|
|`A == B`|`ZF == 1`|
|`A > B`|`CF == 0` 且 `ZF == 0`|
|`A < B`|`CF == 1`|
#### （2）有符号数比较则根据标志位`OF`与`SF`

- A > B: (SF XOR OF)=0 且 ZF=0
- A = B: ZF=1
- A < B: (SF XOR OF)=1

## 3.原码乘法

<img src=./shots/原码乘法.png width=600 height=250/>

对于原码乘法$X\times Y$，其中$P_i$为部分积，其递推公式为：

$$
P_{i+1} = 2^{-1}(P_i + X \times Y_{n-i}) \quad (i=0, 1, 2, 3, \cdots, n-1) \qquad (6-4)
$$

设 $P_0 = 0$，无符号数乘法过程可以归结为循环地计算下列算式的过程：

$$
\begin{aligned}
P_1 &= 2^{-1}(P_0 + X \times Y_n) \\\\
P_2 &= 2^{-1}(P_1 + X \times Y_{n-1}) \\\\
&\vdots \\\\
P_n &= 2^{-1}(P_{n-1} + X \times Y_1)
\end{aligned}
$$

对于上述推导过程中的部分积 $P_i$，每一步迭代过程如下：

1. 取乘数的最低位 $Y_{n-i}$，做判断。
2. 若 $Y_{n-i}$ 的值为 $1$，则将上一步迭代部分积 $P_i$ 与 $X$ 相加；若 $Y_{n-i}$ 为 $0$，则什么也不做。
3. 右移一位，产生本次部分积 $P_{i+1}$。

<img src=./shots/原码乘法示例.png width=600 height=400/>

## 4.补码乘法（Booth算法）

运算规则：

1. 乘数最低位增加一位辅助位$Y_{-1}=0$

2. 根据$Y_iY_{i-1}$的值，决定是“$+[x]_{\text{补}}$” “$-[x]_{\text{补}}$”还是“$+0$”

	- 若$Y_iY_{i-1}=01$，则$[P_{i+1}]_{\text{补}}=[2^{-1}(P_i+x)]_{\text{补}}$
	- 若$Y_iY_{i-1}=10$，则$[P_{i+1}]_{\text{补}}=[2^{-1}(P_i-x)]_{\text{补}}$
	- 若$Y_iY_{i-1}=00\text{或}11$，则$[P_{i+1}]_{\text{补}}=[2^{-1}(P_i+0)]_{\text{补}}$

3. 每次加减后，算术右移一位得到部分积

4. 重复第2步和第3步n次，结果得$[x\times y]_{\text{补}}$

<img src=./shots/补码乘法示例.png width=600 height=400/>

## 5.除法

[康康B站](https://www.bilibili.com/video/BV1DY4y177dV/?spm_id_from=333.337.search-card.all.click&vd_source=eb316f5c08b70e6309a954af30c55650)
### （1）恢复余数法

1. **预置：** 将被除数和除数的绝对值准备好。
2. **循环：**
    - 将当前余数左移一位。
    - **试减：** 余数减去除数。
    - **判断：**
        - 若结果非负，商位为1，保留新余数。
        - 若结果为负，商位为0，**余数加回除数（恢复）**。
3. **符号：** 商的符号单独根据被除数和除数的符号确定（同号为正，异号为负）。

Ex.$[x]_{\text{原}}=0.1011$，$[y]_{\text{原}}=1.1101$，计算$[x/y]_{\text{原}}$

<img src=./shots/恢复余数法.png width=600 height=400/>

### （2）不恢复余数法
$$\text{正、1、减、负、0、加}$$
1. **预置：** 将被除数和除数的绝对值准备好。
2. **第一次操作：** 余数左移一位，然后减去除数。
3. **后续循环：**
    - **判断余数符号：**
        - 若上一次余数非负：商位为1，当前余数左移一位，**再减**除数。
        - 若上一次余数负：商位为0，当前余数左移一位，**再加**除数。
4. **最终校正：** 循环结束后，若最终余数为负，需将其加回除数进行校正。
5. **符号：** 商的符号单独根据被除数和除数的符号确定。

Ex.$[x]_{\text{原}}=0.1011$，$[y]_{\text{原}}=1.1101$，计算$[x/y]_{\text{原}}$

<img src=./shots/不恢复余数法.png width=600 height=400/>
### （3）补码除法

[康康B站](https://www.bilibili.com/video/BV1ng411Z7Zf/?spm_id_from=333.337.search-card.all.click)

- **预置：**
    
    - 将**被除数**放在余数寄存器（通常和商寄存器合用，或一部分在余数寄存器，另一部分在商寄存器）。
    - 将**除数**放在除数寄存器。
    - 商寄存器清零。
    - **符号位：** 不需要单独处理，运算过程中自然产生。

- **循环（迭代次数等于商的位数）：**
    
    - **左移：** 将当前部分余数和商寄存器整体逻辑左移一位 (最高位移入最低位)。
    - **试减（转化为加补码）：**
        - **判断当前余数与除数符号：**
            - 如果当前余数和除数符号**相同**，则进行**减法**操作 (即加上除数的补码)。
            - 如果当前余数和除数符号**不同**，则进行**加法**操作 (即加上除数的原码)。
    - **判断结果余数的符号：**
        - 若结果余数符号与**原先余数符号相同**：表示“够减”或“加对了”。商位为 '1'。保留新余数。
        - 若结果余数符号与**原先余数符号不同**：表示“不够减”或“加错了”。商位为 '0'。需要**恢复**：将刚才的操作反向（如果是减法就加回除数，如果是加法就减去除数），恢复到操作前的状态。

- **最终余数修正：** 循环结束后，如果最终余数的符号与被除数符号不同（且不为0），需要加上除数的绝对值进行修正，使其符号与被除数相同。
