## 1.指令执行的六个基本步骤（Instruction Cycle）

| 步骤  | 名称   | 含义       | 主要内容              |
| --- | ---- | -------- | ----------------- |
| 1️  | 取指令  | 从内存中读取指令 | 获取指令地址、长度（定长或变长）  |
| 2   | 译码   | 解析指令含义   | 得出操作类型、操作数个数、编码格式 |
| 3️  | 取操作数 | 获取操作数    | 根据地址码/寻址方式，访问操作数  |
| 4️  | 执行   | 执行指令     | 根据操作类型计算，更新标志位    |
| 5️  | 存结果  | 保存结果     | 将结果存入目标位置（寄存器/内存） |
| 6️  | 下一条  | 更新 PC    | 计算下条指令地址（顺序或跳转）   |

## 2. 一条指令必须包含的基本信息（显式或隐式）

| 序号  | 信息名称            | 说明                    | 典型表示方式                         |
| --- | --------------- | --------------------- | ------------------------------ |
| ①   | **操作码（Opcode）** | 指明要执行哪种操作（如加法、存储、跳转等） | 固定或可变长度                        |
| ②   | **源操作数参照**      | 指明操作所需的源数据位置          | 主/虚存、寄存器、I/O 端口、指令本身（立即数）      |
| ③   | **结果值参照**       | 指明运算结果应存放在哪里（目的地址）    | 主/虚存、寄存器、I/O 端口                |
| ④   | **下一条指令地址**     | 指明执行完当前指令后，去哪里取下一条指令  | 正常顺序：隐含在 PC 中  <br>跳转/转移：指令中给出 |
|     |                 |                       |                                |
## 3.假设：A=地址字段值，R=寄存器编号，EA=有效地址， (X)=X中的内容

| 寻址方式      | 算法           | 主要优点          | 主要缺点         | 操作数位置    |
| --------- | ------------ | ------------- | ------------ | -------- |
| **立即数**   | 操作数 = A      | 指令执行速度快       | 操作数幅值有限      | 指令（寄存器中） |
| **直接**    | EA = A       | 有效地址计算简单      | 地址范围有限       | 内存       |
| **间接**    | EA = (A)     | 有效地址范围大       | 多次存储器访问      | 内存       |
| **寄存器直接** | 操作数 = (R)    | 指令执行快，指令短     | 地址范围有限       | 寄存器      |
| **寄存器间接** | EA = (R)     | 地址范围大         | 需要额外一次存储器访问  | 内存       |
| **偏移**    | EA = A + (R) | 灵活，适合数组、结构等访问 | 有效地址计算复杂     | 内存       |
| **栈寻址**   | EA = 栈顶（SP）  | 指令短，隐式寻址      | 应用范围有限，依赖栈结构 | 内存       |
|           |              |               |              |          |
## 4.三种偏移寻址方式对比表

| 寻址方式     | EA 计算方式       | 基准地址来源       | 偏移量来源      | 示例指令（伪代码）          | 含义说明                 |
| -------- | ------------- | ------------ | ---------- | ------------------ | -------------------- |
| **相对寻址** | `EA = PC + A` | 当前 PC（程序计数器） | 指令中带符号常数 A | `BEQ R1, R2, +8`   | 相等则跳转到 PC+8 指令       |
| **基址寻址** | `EA = B + A`  | 基址寄存器 B      | 指令中偏移量 A   | `MOV R1, 8(R3)`    | 从地址 R3+8 读取数据到 R1    |
| **变址寻址** | `EA = A + I`  | 指令中基址 A      | 变址寄存器 I    | `MOV R1, 1000(R2)` | 从地址 1000+R2 读取数据到 R1 |

## 5.变址寻址示例

假设数组 `arr` 的首地址在寄存器 `x10` 中，数组中每个元素占 4 字节（word），我们想读取 `arr[3]` 到寄存器 `x5` 中：
```lw x5, 12(x10)   # x5 ← Mem[x10 + 12]```

| 部分    | 说明          |
| ----- | ----------- |
| `lw`  | 指令：从内存读取一个字 |
| `x5`  | 目的寄存器（接收数据） |
| `8`   | 偏移量（立即数）    |
| `x10` | 基址寄存器       |

## 6. 中断/异常分类总览

| 分类       | 子类    | 来源位置  | 举例                    | 特点说明           |
| -------- | ----- | ----- | --------------------- | -------------- |
| **内部异常** | 硬故障中断 | CPU内部 | 电源掉电、CPU硬件出故障         | 通常是**硬件错误**    |
|          | 程序性中断 | CPU内部 | 除0、越界、非法指令、缺页         | 指令执行时产生的**例外** |
| **外部中断** | 外设中断  | CPU外部 | 时钟中断、I/O设备没准备好、DMA未完成 | 由**外设或定时器触发**  |

## 7.长度32位RISC-V指令格式

![[RISC-V指令格式.png]]

## 8.RTL规定：

 - R\[r]: 通用寄存器r的内容
 - M\[addr]: 存储单元addr的内容
 - M\[R\[r]]: 寄存器r的内容所指存储单元的内容
 - PC: PC的内容
 - M\[PC]: PC所指存储单元的内容
 - SEXT\[imm]: 对imm进行符号拓展
 - ZEXT\[imm]: 对imm进行零拓展
 
 > 传送方向用←表示，即传送源在右，传送目的在左
 
## 9.U型指令举例：

请给出C语句`int x = -8191;`对应的 RISC-V机器级代码：
* -8191的机器数为：1111 1111 1111 1111 1110 0000 0000 0001

```
1111 1111 1111 1111 1110 00101 0110111 
lui x5, 1048574 
#R[x5]←FFFFE000H(-8192)

0000 0000 0001 00101 000 00101 0010011 
addi x5, x5, 1  
#R[x5]←R[x5]+SEXT[001H]
```

C语句：`int x = 8191;`
* 8191的机器数为：0000 0000 0000 0000 0001 1111 1111 1111

```
❌
0000 0000 0000 0000 0001 00101 0110111  
lui x5, 1 
#R[x5]← 0000 1000H  （4096）

1111 1111 1111 00101 000 00101 0010011  
addi x5, x5,-1
#R[x5]←R[x5]+SEXT[FFFH]

**因为低12位中第一位为1，addi按符号扩展相加！结果为4095**

✅
0000 0000 0000 0000 0010 00101 0110111  
lui x5, 2  
#R[x5]← 0000 2000H  （8192）

1111 1111 1111 00101 000 00101 0010011  
addi x5, x5,-1 
#R[x5]←R[x5]+SEXT[FFFH]
```


## 10.R型指令举例

若int型变量x、y、z分别存放在寄存器x5、x6、x7中，写出C语句“z=x+y;”对应的RISC-V机器级代码，要求检测是否溢出。
* 当x、y为int类型时，若“y<0且x+y≥x”或者 “y≥0且x+y<x”，则x+y溢出。可通过slti指令对y与0进行比较。

```
0000000 00110 00101 000 00111 0110011 
add x7,x5,x6 
#R[x7]←R[x5]+R[x6]

0000 0000 0000 00110 010 11100 0010011 
slti x28,x6,0 
#若R[x6]<0，则R[x28]←1

0000000 00101 00111 010 11101 0110011 
slt x29,x7,x5 
#若R[x7]<R[x5] 则R[x29]←1

0000010 11101 11100 001 10000 1100011 
bne x28,x29,overflew 
#若R[x28]≠R[x29]，则转溢出处理
overflew:  xxxxxxxx （某指令）

```

## 11.RV32I代表指令及其含义

| 指令                    | 操作语义                                                     | 功能说明                                                      |
| --------------------- | -------------------------------------------------------- | --------------------------------------------------------- |
| `add rd, rs1, rs2`    | `R[rd] ← R[rs1] + R[rs2]`<br>`PC ← PC + 4`               | 加法指令，不进行溢出判断。<br>从 `PC` 所指内存中取指令，并使 `PC` 增加 4。            |
| `slt rd, rs1, rs2`    | `if (R[rs1] < R[rs2]) R[rd] ← 1`<br>`else R[rd] ← 0`     | **有符号比较**，若 `rs1 < rs2`，则 `rd` 为 1，否则为 0。                 |
| `sltu rd, rs1, rs2`   | `if (R[rs1] < R[rs2]) R[rd] ← 1`<br>`else R[rd] ← 0`     | **无符号比较**，若 `rs1 < rs2`，则 `rd` 为 1，否则为 0。                 |
| `ori rd, rs1, imm12`  | `R[rd] ← R[rs1] OR SEXT(imm12)`                          | 将 `rs1` 和符号扩展后的 `imm12` 按位或，结果送 `rd`。                     |
| `lui rd, imm20`       | `R[rd] ← imm20 << 12`                                    | 将 `imm20` 放入 `rd` 的高 20 位，低 12 位清零。                       |
| `lw rd, rs1, imm12`   | `Addr ← R[rs1] + SEXT(imm12)`<br>`R[rd] ← M[Addr]`       | 取地址后从内存读取一个字（4 字节），送入 `rd`。                               |
| `sw rs2, rs1, imm12`  | `Addr ← R[rs1] + SEXT(imm12)`<br>`M[Addr] ← R[rs2]`      | 取地址后将 `rs2` 的值写入内存地址 `Addr`。                              |
| `beq rs1, rs2, imm12` | `if (R[rs1] == R[rs2])`<br>`PC ← PC + (SEXT(imm12) × 2)` | 比较两个寄存器是否相等，相等则跳转。<br>跳转采用**相对寻址**，偏移为 `imm12 × 2`（符号扩展）。 |
| `jal rd, imm20`       | `R[rd] ← PC + 4`<br>`PC ← PC + (SEXT(imm20) × 2)`        | 过程调用指令，将返回地址保存到 `rd`。<br>跳转目标地址为 PC 加上符号扩展后的 `imm20 × 2`。 |
